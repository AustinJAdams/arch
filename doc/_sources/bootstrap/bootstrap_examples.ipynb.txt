{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bootstrap Examples"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_This setup code is required to run in an IPython notebook_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.simplefilter('ignore')\n",
    "\n",
    "%matplotlib inline\n",
    "import seaborn\n",
    "seaborn.mpl.rcParams['figure.figsize'] = (10.0, 6.0)\n",
    "seaborn.mpl.rcParams['savefig.dpi'] = 90"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sharpe Ratio"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Sharpe Ratio is an important measure of return per unit of risk.  The example shows how to estimate the variance of the Sharpe Ratio and how to construct confidence intervals for the Sharpe Ratio using a long series of U.S. equity data.  First, the data is imported using pandas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import pandas_datareader.data as web\n",
    "try:\n",
    "    ff=web.DataReader('F-F_Research_Data_Factors', 'famafrench')\n",
    "except:\n",
    "    ff=web.DataReader('F-F_Research_Data_Factors_TXT', 'famafrench')\n",
    "ff = ff[0]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The data set contains the Fama-French factors, including the excess market return."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Mkt-RF</th>\n",
       "      <th>SMB</th>\n",
       "      <th>HML</th>\n",
       "      <th>RF</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>count</th>\n",
       "      <td>103.000000</td>\n",
       "      <td>103.000000</td>\n",
       "      <td>103.000000</td>\n",
       "      <td>103.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>mean</th>\n",
       "      <td>1.139806</td>\n",
       "      <td>0.107379</td>\n",
       "      <td>-0.131068</td>\n",
       "      <td>0.020680</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>std</th>\n",
       "      <td>3.542553</td>\n",
       "      <td>2.273547</td>\n",
       "      <td>2.162328</td>\n",
       "      <td>0.037397</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>min</th>\n",
       "      <td>-7.890000</td>\n",
       "      <td>-4.370000</td>\n",
       "      <td>-4.500000</td>\n",
       "      <td>0.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25%</th>\n",
       "      <td>-0.985000</td>\n",
       "      <td>-1.720000</td>\n",
       "      <td>-1.530000</td>\n",
       "      <td>0.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>50%</th>\n",
       "      <td>1.180000</td>\n",
       "      <td>0.320000</td>\n",
       "      <td>-0.290000</td>\n",
       "      <td>0.010000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>75%</th>\n",
       "      <td>3.155000</td>\n",
       "      <td>1.230000</td>\n",
       "      <td>1.015000</td>\n",
       "      <td>0.020000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>max</th>\n",
       "      <td>11.350000</td>\n",
       "      <td>5.490000</td>\n",
       "      <td>8.270000</td>\n",
       "      <td>0.160000</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "           Mkt-RF         SMB         HML          RF\n",
       "count  103.000000  103.000000  103.000000  103.000000\n",
       "mean     1.139806    0.107379   -0.131068    0.020680\n",
       "std      3.542553    2.273547    2.162328    0.037397\n",
       "min     -7.890000   -4.370000   -4.500000    0.000000\n",
       "25%     -0.985000   -1.720000   -1.530000    0.000000\n",
       "50%      1.180000    0.320000   -0.290000    0.010000\n",
       "75%      3.155000    1.230000    1.015000    0.020000\n",
       "max     11.350000    5.490000    8.270000    0.160000"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "excess_market = ff.iloc[:,0]\n",
    "ff.describe()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The next step is to construct a function that computes the Sharpe Ratio.  This function also return the annualized mean and annualized standard deviation which will allow the covariance matrix of these parameters to be estimated using the bootstrap."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sharpe_ratio(x):\n",
    "    mu, sigma = 12 * x.mean(), np.sqrt(12 * x.var())\n",
    "    values = np.array([mu, sigma, mu / sigma ]).squeeze()\n",
    "    index = ['mu', 'sigma', 'SR']\n",
    "    return pd.Series(values, index=index)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The function can be called directly on the data to show full sample estimates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "mu       13.677670\n",
       "sigma    12.271762\n",
       "SR        1.114564\n",
       "dtype: float64"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "params = sharpe_ratio(excess_market)\n",
    "params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### _Warning_\n",
    "\n",
    "_The bootstrap chosen must be appropriate for the data.  Squared returns are serially correlated, and so a time-series bootstrap is required._"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Bootstraps are initialized with any bootstrap specific parameters and the data to be used in the bootstrap.  Here the `12` is the average window length in the Stationary Bootstrap, and the next input is the data to be bootstrapped."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "from arch.bootstrap import StationaryBootstrap\n",
    "bs = StationaryBootstrap(12, excess_market)\n",
    "results = bs.apply(sharpe_ratio, 2500)\n",
    "SR = pd.DataFrame(results[:,-1:], columns=['SR'])\n",
    "fig = SR.hist(bins=40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             mu     sigma        SR\n",
      "mu     7.784073 -1.115602  0.749282\n",
      "sigma -1.115602  1.700518 -0.256969\n",
      "SR     0.749282 -0.256969  0.088170\n",
      "\n",
      "\n",
      "mu       2.789995\n",
      "sigma    1.304039\n",
      "SR       0.296935\n",
      "Name: Std Errors, dtype: float64\n"
     ]
    }
   ],
   "source": [
    "cov = bs.cov(sharpe_ratio, 1000)\n",
    "cov = pd.DataFrame(cov, index=params.index, columns=params.index)\n",
    "print(cov)\n",
    "se = pd.Series(np.sqrt(np.diag(cov)), index=params.index)\n",
    "se.name = 'Std Errors'\n",
    "print('\\n')\n",
    "print(se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   8.299806   9.814779  0.407323\n",
      "Upper  19.090893  15.084889  1.587584\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method='basic')\n",
    "ci = pd.DataFrame(ci, index=['Lower','Upper'], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Alternative confidence intervals can be computed using a variety of methods.  Setting `reuse=True` allows the previous bootstrap results to be used when constructing confidence intervals using alternative methods."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   8.264447   9.458635  0.641545\n",
      "Upper  19.055534  14.728745  1.821806\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method='percentile', reuse=True)\n",
    "ci = pd.DataFrame(ci, index=['Lower','Upper'], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Probit (Statsmodels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second example makes use of a Probit model from Statsmodels.  The demo data is university admissions data which contains a binary variable for being admitted, GRE score, GPA score and quartile rank. This data is downloaded from the internet and imported using pandas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "            admit         gre         gpa       rank\n",
      "count  400.000000  400.000000  400.000000  400.00000\n",
      "mean     0.317500  587.700012    3.389900    2.48500\n",
      "std      0.466087  115.516541    0.380567    0.94446\n",
      "min      0.000000  220.000000    2.260000    1.00000\n",
      "25%      0.000000  520.000000    3.130000    2.00000\n",
      "50%      0.000000  580.000000    3.395000    2.00000\n",
      "75%      1.000000  660.000000    3.670000    3.00000\n",
      "max      1.000000  800.000000    4.000000    4.00000\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "try:\n",
    "    import urllib2\n",
    "    import StringIO\n",
    "except ImportError:\n",
    "    import urllib.request as urllib2\n",
    "    from io import StringIO\n",
    "\n",
    "url = 'https://stats.idre.ucla.edu/stat/stata/dae/binary.dta'\n",
    "binary = pd.read_stata(url)\n",
    "binary = binary.dropna()\n",
    "print(binary.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fitting the model directly"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first steps are to build the regressor and the dependent variable arrays.  Then, using these arrays, the model can be estimated by calling `fit`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const   -3.003536\n",
      "gre      0.001643\n",
      "gpa      0.454575\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "endog = binary[['admit']]\n",
    "exog = binary[['gre','gpa']]\n",
    "const = pd.Series(np.ones(exog.shape[0]), index=endog.index)\n",
    "const.name = 'Const'\n",
    "exog = pd.DataFrame([const, exog.gre, exog.gpa]).T\n",
    "# Estimate the model\n",
    "import statsmodels.api as sm\n",
    "mod = sm.Probit(endog, exog)\n",
    "fit = mod.fit(disp=0)\n",
    "params = fit.params\n",
    "print(params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The wrapper function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Most models in Statsmodels are implemented as classes, require an explicit call to `fit` and return a class containing parameter estimates and other quantities.  These classes cannot be directly used with the bootstrap methods.  However, a simple wrapper can be written that takes the data as the only inputs and returns parameters estimated using a Statsmodel model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap(endog, exog):\n",
    "    return sm.Probit(endog, exog).fit(disp=0).params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A call to this function should return the same parameter values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Const   -3.003536\n",
       "gre      0.001643\n",
       "gpa      0.454575\n",
       "dtype: float64"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "probit_wrap(endog, exog)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The wrapper can be directly used to estimate the parameter covariance or to construct confidence intervals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.401232 -6.505728e-05 -0.104472\n",
      "gre   -0.000065  4.143598e-07 -0.000054\n",
      "gpa   -0.104472 -5.358712e-05  0.039889\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import IIDBootstrap \n",
    "bs = IIDBootstrap(endog=endog, exog=exog)\n",
    "cov = bs.cov(probit_wrap, 1000)\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const    0.633429\n",
      "gre      0.000644\n",
      "gpa      0.199722\n",
      "dtype: float64\n",
      "T-stats\n",
      "Const   -4.741712\n",
      "gre      2.551680\n",
      "gpa      2.276042\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "se = pd.Series(np.sqrt(np.diag(cov)), index=exog.columns)\n",
    "print(se)\n",
    "print('T-stats')\n",
    "print(params / se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const       gre       gpa\n",
      "Lower -4.275146  0.000381  0.061935\n",
      "Upper -1.745115  0.002835  0.851292\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(probit_wrap, 1000, method='basic')\n",
    "ci = pd.DataFrame(ci, index=['Lower','Upper'], columns=exog.columns)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Speeding things up"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Starting values can be provided to `fit` which can save time finding starting values.  Since the bootstrap parameter estimates should be close to the original sample estimates, the full sample estimated parameters are reasonable starting values.  These can be passed using the `extra_kwargs` dictionary to a modified wrapper that will accept a keyword argument containing starting values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap_start_params(endog, exog, start_params=None):\n",
    "    return sm.Probit(endog, exog).fit(start_params=start_params, disp=0).params"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.401232 -6.505728e-05 -0.104472\n",
      "gre   -0.000065  4.143598e-07 -0.000054\n",
      "gpa   -0.104472 -5.358712e-05  0.039889\n"
     ]
    }
   ],
   "source": [
    "bs.reset()  # Reset to original state for comparability\n",
    "cov = bs.cov(probit_wrap_start_params, 1000, extra_kwargs={'start_params': params.values})\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
